# 1. Создать класс TrafficLight (светофор).
#
#     определить у него один атрибут color (цвет) и метод running (запуск);
#     атрибут реализовать как приватный;
#     в рамках метода реализовать переключение светофора в режимы: красный, жёлтый, зелёный;
#     продолжительность первого состояния (красный) составляет 7 секунд,
#     второго (жёлтый) — 2 секунды, третьего (зелёный) — на ваше усмотрение;
#     переключение между режимами должно осуществляться только в указанном порядке (красный, жёлтый, зелёный);
#     проверить работу примера, создав экземпляр и вызвав описанный метод.
#
# Задачу можно усложнить, реализовав проверку порядка режимов.
# При его нарушении выводить соответствующее сообщение и завершать скрипт.

from itertools import cycle
from time import sleep


class TrafficLight:
    _color = ''
    # Между зелёным и красным обязательно должен быть желтый. Безопасность на дорогах важнее условия задачи :)
    __traffic_light_cycle = [('red', 7), ('yellow', 2), ('green', 5), ('yellow', 2)]

    def Running(self):
        i = 0

        for color, pause in cycle(self.__traffic_light_cycle):
            if i > 10  * len(self.__traffic_light_cycle):  # Принудительный выход из цикла
                break

            self.__TrafficLightSwitching(color)
            print(f'{self._color} traffic light is on')
            sleep(pause)
            i += 1

    # Игрался с присвоением значений атрибутам через защищённый метод
    def __TrafficLightSwitching(self, color):
        self._color = color
        pass


a = TrafficLight()

a.Running()



# 2. Реализовать класс Road (дорога).
#
#     определить атрибуты: length (длина), width (ширина);
#     значения атрибутов должны передаваться при создании экземпляра класса;
#     атрибуты сделать защищёнными;
#     определить метод расчёта массы асфальта, необходимого для покрытия всей дороги;
#     использовать формулу: длина*ширина*масса асфальта для покрытия одного кв. метра дороги асфальтом,
#     толщиной в 1 см*число см толщины полотна;
#     проверить работу метода.
#
# Например: 20 м*5000 м*25 кг*5 см = 12500 т.


class Road:
    __density = 25

    def __init__(self, length, width):
        self.__length = int(length)
        self.__width = int(width)

    def CalculateMass(self, thickness = 1):
        mass = self.__width * self.__length * thickness * self.__density
        return f'Необходимое количество асфальта: {mass / 1000} тонн'


b = Road(5000, 20)

print(b.CalculateMass(5))
print(b.CalculateMass())


# 3. Реализовать базовый класс Worker (работник).
#
#     определить атрибуты: name, surname, position (должность), income (доход);
#     последний атрибут должен быть защищённым и ссылаться на словарь, содержащий элементы: оклад и премия, например,
#     {"wage": wage, "bonus": bonus};
#     создать класс Position (должность) на базе класса Worker;
#     в классе Position реализовать методы получения полного имени сотрудника (get_full_name) и дохода с учётом премии
#     (get_total_income);
#     проверить работу примера на реальных данных: создать экземпляры класса Position, передать данные,
#     проверить значения атрибутов, вызвать методы экземпляров.
#
# 4. Реализуйте базовый класс Car.
#
#     у класса должны быть следующие атрибуты: speed, color, name, is_police (булево). А также методы: go, stop, turn(direction), которые должны сообщать, что машина поехала, остановилась, повернула (куда);
#     опишите несколько дочерних классов: TownCar, SportCar, WorkCar, PoliceCar;
#     добавьте в базовый класс метод show_speed, который должен показывать текущую скорость автомобиля;
#     для классов TownCar и WorkCar переопределите метод show_speed. При значении скорости свыше 60 (TownCar) и 40 (WorkCar) должно выводиться сообщение о превышении скорости.
#
# Создайте экземпляры классов, передайте значения атрибутов. Выполните доступ к атрибутам, выведите результат. Вызовите методы и покажите результат.
# 5. Реализовать класс Stationery (канцелярская принадлежность).
#
#     определить в нём атрибут title (название) и метод draw (отрисовка). Метод выводит сообщение «Запуск отрисовки»;
#     создать три дочерних класса Pen (ручка), Pencil (карандаш), Handle (маркер);
#     в каждом классе реализовать переопределение метода draw. Для каждого класса метод должен выводить уникальное сообщение;
#     создать экземпляры классов и проверить, что выведет описанный метод для каждого экземпляра.